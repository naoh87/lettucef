// Code generated by codegen/run; DO NOT EDIT
package dev.naoh.lettucef.api.commands

import dev.naoh.lettucef.api.models._
import io.lettuce.core.ScanArgs
import io.lettuce.core.ScanCursor


trait SetCommandsF[F[_], K, V] {

  def sadd(key: K, members: V*): F[Long]
  
  def scard(key: K): F[Long]
  
  def sdiff(keys: K*): F[Set[V]]
  
  def sdiffstore(destination: K, keys: K*): F[Long]
  
  def sinter(keys: K*): F[Set[V]]
  
  def sintercard(keys: K*): F[Long]
  
  def sintercard(limit: Long, keys: K*): F[Long]
  
  def sinterstore(destination: K, keys: K*): F[Long]
  
  def sismember(key: K, member: V): F[Boolean]
  
  def smembers(key: K): F[Set[V]]
  
  def smismember(key: K, members: V*): F[Seq[Boolean]]
  
  def smove(source: K, destination: K, member: V): F[Boolean]
  
  def spop(key: K): F[Option[V]]
  
  def spop(key: K, count: Long): F[Set[V]]
  
  def srandmember(key: K): F[Option[V]]
  
  def srandmember(key: K, count: Long): F[Seq[V]]
  
  def srem(key: K, members: V*): F[Long]
  
  def sunion(keys: K*): F[Set[V]]
  
  def sunionstore(destination: K, keys: K*): F[Long]
  
  def sscan(key: K): F[RedisScanCursor[V]]
  
  def sscan(key: K, scanArgs: ScanArgs): F[RedisScanCursor[V]]
  
  def sscan(key: K, scanCursor: ScanCursor, scanArgs: ScanArgs): F[RedisScanCursor[V]]
  
  def sscan(key: K, scanCursor: ScanCursor): F[RedisScanCursor[V]]
  
}
